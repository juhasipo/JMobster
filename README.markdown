JMobster - Java Model to Backbone.js generator
==============================================
Version preview-alpha 0.2

### Purpose and Current Status

**The architecture is being redesigned at the moment. A lot of things are broken in this branch.**

The purpose of this project is to enable automatic model generation from Java POJOs to Backbone.js models. It also
supports client side validation generation from standard JSR-303 validation annotations. At the moment it's still
more of an proof of concept type of project, but in future as I found some use for it may become more mature.

The project has just started so the backwards compatibility may break once in a while due to sudden urges to refactor
the code. The current version is not well tested yet with real Backbone.js client nor a working server so there will
be a lot of bugs.

![JMobster process](https://raw.github.com/juhasipo/JMobster/redesign/img/process.png)


### Requirements

* JDK 6 (SE or EE)
* Backbone.js (tested only with 0.9.2)
* Backbone.Validations

At the moment only Java to Backbone.js model conversion is supported. Validation requires
[Backbone.Validations](https://github.com/n-time/backbone.validations) plugin to work. Java dependencies are
handled in Gradle build file.


Usage
-----

### Basic usage

Basic usage is simple. Create Java classes, use JSR-303 annotations and give the classes to the generator.
```java
public class UserDto {
    @NotNull
    @Size(max = 255)
    private String fullname;

    @NotNull
    @Size(max = 255)
    private String username;

    @NotNull
    @Min(1900)
    private Integer birthYear = 1900;

    @Size(min = 1)
    private String[] roles = { "VIEW_PAGES", "EDIT_OWN_PAGES" };

    // Getters and setters omitted
}
```
And now you can create a model generator instance:

```java
ModelWriter modelWriter = new StreamModelWriter("models.js");
ModelGenerator generator = JMobsterFactory.getInstance("Backbone.js", modelWriter);
```

And give the model class to the generator:

```java
generator.process(UserDto.class);
```

This will write a Backbone.js model file `models.js` to your working
directory. The default naming strategy will remove Dto suffix from the
model class name.


```javascript
/*
 * Auto-generated file
 */
var Models = {
    User: Backbone.Model.extend({
        defaults: function() {
            return {
                fullName: "",
                username: "",
                birthYear: 1900,
                roles: ["VIEW_PAGES", "EDIT_OWN_PAGES"]
            }
        },
        validate: {
            fullname: {
                required: true,
                minlength: 0,
                maxlength: 255
            },
            username: {
                required: true,
                minlength: 0,
                maxlength: 255
            },
            birthYear: {
                required: true,
                type: "number",
                min: 1900
            },
            roles: {
                minlength: 1
            }
        }
    })
};
```

You can also give the method more than classes. This can be done just by giving more than one class as parameter (vararg),
an array of classes or a List of classes.

```java
generator.process(Model1.class, Model2.class, Model3.class);
generator.process(new Class[] {Model1.class, Model2.class, Model3.class});
generator.process(classList);
```



### Property Scanning

There are two field scanning mode in JMobster: _DIRECT\_FIELD\_ACCESS_ and _BEAN\_PROPERTY_. The _DIRECT\_FIELD\_ACCESS_
mode is the default mode and in it the fields are find every member variable and use them as model field.
The validator annotations must be written for the member variables. The mode doesn't care about the visibility
of the fields, so all public, protected and private fields are considered equal in that sense.

_BEAN\_PROPERTY_ mode will use standard getter methods to find available model fields (e.g. _getName()_ for field "name").
This mode will ignore _getClass()_ getter. in this mode the annotations must be written to the getter methods in order
them to work since it won't be possible to find the corresponding member variable just with the method name (the getter
can return formatted or combined field data). In this mode, only the public getters are taken into account so any other
getters won't show up in the model.

In the next example a simple class is generated by using the different field scanning modes.

```java
public class ScanningModeDemo {
    @Pattern(regexp = "[\\w]*")
    private String firstName = "John";
    @Pattern(regexp = "[\\w]*")
    private String lastName = "Doe";

    @Size(min = 0, max = 255)
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

In _DIRECT\_FIELD\_ACCESS_ this will result:

```javascript
var Models = {
    ScanningModeDemo: Backbone.Model.extend({
        defaults: function() {
            return {
                firstName: "John",
                lastName: "Doe"
            }
        },
        validate: {
            firstName: {
                pattern: /[\w]*/
            },
            lastName: {
                pattern: /[\w]*/
            }
        }
    })
};
```

In _BEAN\_PROPERTY_ mode this will result:

```javascript
var Models = {
    ScanningModeDemo: Backbone.Model.extend({
        defaults: function() {
            return {
                fullName: "John Doe"
            }
        },
        validate: {
            fullName: {
                maxlength: 255
            }
        }
    })
};
```

In both modes the _IgnoreField_ annotation will ignore the field and it won't be used in the generated model. For
_BEAN\_PROPERTY_ mode the annotations must be written for the getter method and in _DIRECT\_FIELD\_ACCESS_ for the
member variable.


In addition to scanning modes, there are extra settings that determine what kind of fields are included. The current
options are to toggle static and/or final fields. Final field mode affects both scanning modes, but static field mode
only works with _DIRECT\_FIELD\_ACCESS_ mode. By default final fields are included but static fields are not.

### Classes and Default Values

#### TODO


Default Process
---------------

JMobster has default implementations for standard JSR-303 validations and a set of default implementations for
processing models. The default classes should work for most cases.

Configuring
-----------

### Custom Validators

To support new validators you will have implement several classes.

#### Validator Annotation

The first phase is to create your annotation. The annotation should have a method calles
*groups* which has to return an array of *Classes*. This method is used for filtering annotations
when constructing *ModelFields*.


#### Validator Class

The next phase is to create a wrapper for your annotation. The wrapper will be used in later phase of the process
to get annotation values that should be written to *DataWriter*. These validator wrapper classes are generic and they
only need to be implemented once per annotation.

Here is an example of *MyValidator* for a custom *MyAnnotation* validator annotation:
```java
public class MyValidator extends BaseValidator {
    private String requiredValue;
    private String optionalValue;

    @Override
    public void init( AnnotationBag annotationBag ) {
        MyAnnotation myAnnotation = annotationBag.getAnnotation(MyAnnotation.class);
        this.requiredValue = myAnnotation.value();
        if( annotationBag.hasAnnotation(MyOptionalAnnotation.class) ) {
            MyOptionalAnnotation myOptionalAnnotation = annotationBag.getAnnotation(MyOptionalAnnotation.class);
            optionalValue = myOptionalAnnotation.value();
        }
    }

    // Getters
}
```

As you can see, the *MyValidator* contains a two fields *requiredValue* and *optionalValue*. Values is set in the *init* method
which takes an *AnnotationBag* as parameter. *AnnotationBag* contains all the annotations which are required
for your annotation and optional annotations. These required and optional annotations are configured later. Difference
between required and optional annotations is that required annotations are quaranteed to be present when the
*Validator* is initialized. Optional annotations are not.


#### Configuring Required and Optional Annotations

Now that you have your *Validator* class, it requires required and optional annotations. This is done in
*ValidatorFactories*. You have to choises:

1. Use *DefaultValidatorFactory and configure* it to use your own custom validator
2. Create your own *ValidatorFactory* which you configure by yourself

Using the *DefaultValidatorFactory* is the easiest choise and it will contain supported JSR-303 validators. You can
configure like following:

```java
DefaultValidatorFactory validatorFactory = new DefaultValidatorFactory();
validatorFactory.setValidator(MyValidator.class, RequiredTypes.get(MyAnnotation.class), OptionalTypes.get());
```

This will add *MyValidator* class that will require *MyAnnotation* annotation.

#### ValidatorWriter Class

Now that you have your validator configured, you can make your *ValidatorWriter*. *ValidatorWriters* are language
and framework specific. They get previously written *Validator* class as parameter.

Here is an example of a *ValidatorWriter*:
```java
public class MyValidatorWriter extends BaseValidatorWriter<MyValidator, JavaScriptWriter> {
    public MyValidatorWriter() {
        super( MyValidator.class );
    }

    @Override
    protected void write( JavaScriptWriter writer, MyValidator validator, boolean isLast ) {
        String value = validator.getRequiredValue();
        if( validator.hasOptionalValue() ) {
            value += validator.getOptionalValue();
        }
        writer.writeKeyValue("value", value, isLast);
    }
}
```

The example implementation uses higher level *JavaScriptWriter* for output. The first generic parameter
must match your *Validator* (in this case *MyValidator*) and the second must match or be super clasee for
the writer that your frameworks' *ValidatorWriterManager* uses.

In the constructor you will have to give the type of *Validator* your *ValidatorWriter* supports. This has
to be done manually due to Java's type erasure. The writing itself is implemented in *write* method. You will get
the writer to use and the validator as parameters. There is also *isLast* boolean parameter which is true
if the validator you are writing is the last validator for the current *ModelField*.

**Notice**: *ValidatorWriters* instances are reused so the internal state will stay across calls.


#### Configuring ValidatorWriter to ValidatorWriterManager

Once you have your *ValidatorWriter*, you have to configure *ValidatorWriterManager* to use your *ValidatorWriter*.

```java
ConcreteValidatorWriterManager validatorWriterManager = new ConcreteValidatorWriterManager();
validatorWriterManager.setValidator(new MyValidatorWriter());
```

Now you have added support for your own validation annotation.

### Custom Target Platform

#### Supporting New Language
Create new DataWriter...

#### Supporting New Target Framework
Create new Model processor...

### Model Naming Strategies

In order to customize the produced model's name, a model naming strategy can be implemented. It basically
takes a Model class and returns the name for the model as string.

