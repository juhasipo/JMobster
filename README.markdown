JMobster - Java Model to Backbone.js generator
==============================================
Version preview-alpha 0.2

### Purpose and Current Status

**The architecture is being redesigned at the moment. A lot of things are broken in this branch.**

The purpose of this project is to enable automatic model generation from Java POJOs to Backbone.js models. It also
supports client side validation generation from standard JSR-303 validation annotations. At the moment it's still
more of an proof of concept type of project, but in future as I found some use for it may become more mature.

The project has just started so the backwards compatibility may break once in a while due to sudden urges to refactor
the code. The current version is not well tested yet with real Backbone.js client nor a working server so there will
be a lot of bugs.


### Requirements

* JDK 6 (SE or EE)
* Backbone.js (tested only with 0.9.2)
* Backbone.Validations

At the moment only Java to Backbone.js model conversion is supported. Validation requires
[Backbone.Validations](https://github.com/n-time/backbone.validations) plugin to work. Java dependencies are
handled in Gradle build file.


Usage
-----

### Basic usage

Basic usage is simple. Create Java classes, use JSR-303 annotations and give the classes to the generator.
```java
public class UserDto {
    @NotNull
    @Size(max = 255)
    private String fullname;

    @NotNull
    @Size(max = 255)
    private String username;

    @NotNull
    @Min(1900)
    private Integer birthYear = 1900;

    @Size(min = 1)
    private String[] roles = { "VIEW_PAGES", "EDIT_OWN_PAGES" };

    // Getters and setters omitted
}
```
And now you can create a model generator instance:

```java
ModelWriter modelWriter = new StreamModelWriter("models.js");
ModelGenerator generator = JMobsterFactory.getInstance("Backbone.js", modelWriter);
```

And give the model class to the generator:

```java
generator.process(UserDto.class);
```

This will write a Backbone.js model file `models.js` to your working
directory. The default naming strategy will remove Dto suffix from the
model class name.


```javascript
/*
 * Auto-generated file
 */
var Models = {
    User: Backbone.Model.extend({
        defaults: function() {
            return {
                fullName: "",
                username: "",
                birthYear: 1900,
                roles: ["VIEW_PAGES", "EDIT_OWN_PAGES"]
            }
        },
        validate: {
            fullname: {
                required: true,
                minlength: 0,
                maxlength: 255
            },
            username: {
                required: true,
                minlength: 0,
                maxlength: 255
            },
            birthYear: {
                required: true,
                type: "number",
                min: 1900
            },
            roles: {
                minlength: 1
            }
        }
    })
};
```

You can also give the method more than classes. This can be done just by giving more than one class as parameter (vararg),
an array of classes or a List of classes.

```java
generator.process(Model1.class, Model2.class, Model3.class);
generator.process(new Class[] {Model1.class, Model2.class, Model3.class});
generator.process(classList);
```



### Property Scanning

There are two field scanning mode in JMobster: _DIRECT\_FIELD\_ACCESS_ and _BEAN\_PROPERTY_. The _DIRECT\_FIELD\_ACCESS_
mode is the default mode and in it the fields are find every member variable and use them as model field.
The validator annotations must be written for the member variables. The mode doesn't care about the visibility
of the fields, so all public, protected and private fields are considered equal in that sense.

_BEAN\_PROPERTY_ mode will use standard getter methods to find available model fields (e.g. _getName()_ for field "name").
This mode will ignore _getClass()_ getter. in this mode the annotations must be written to the getter methods in order
them to work since it won't be possible to find the corresponding member variable just with the method name (the getter
can return formatted or combined field data). In this mode, only the public getters are taken into account so any other
getters won't show up in the model.

In the next example a simple class is generated by using the different field scanning modes.

```java
public class ScanningModeDemo {
    @Pattern(regexp = "[\\w]*")
    private String firstName = "John";
    @Pattern(regexp = "[\\w]*")
    private String lastName = "Doe";

    @Size(min = 0, max = 255)
    public String getFullName() {
        return firstName + " " + lastName;
    }
}
```

In _DIRECT\_FIELD\_ACCESS_ this will result:

```javascript
var Models = {
    ScanningModeDemo: Backbone.Model.extend({
        defaults: function() {
            return {
                firstName: "John",
                lastName: "Doe"
            }
        },
        validate: {
            firstName: {
                pattern: /[\w]*/
            },
            lastName: {
                pattern: /[\w]*/
            }
        }
    })
};
```

In _BEAN\_PROPERTY_ mode this will result:

```javascript
var Models = {
    ScanningModeDemo: Backbone.Model.extend({
        defaults: function() {
            return {
                fullName: "John Doe"
            }
        },
        validate: {
            fullName: {
                maxlength: 255
            }
        }
    })
};
```

In both modes the _IgnoreField_ annotation will ignore the field and it won't be used in the generated model. For
_BEAN\_PROPERTY_ mode the annotations must be written for the getter method and in _DIRECT\_FIELD\_ACCESS_ for the
member variable.


In addition to scanning modes, there are extra settings that determine what kind of fields are included. The current
options are to toggle static and/or final fields. Final field mode affects both scanning modes, but static field mode
only works with _DIRECT\_FIELD\_ACCESS_ mode. By default final fields are included but static fields are not.

### Classes and Default Values

#### Requirements for Classes

Classes that are processed with JMobster have to have a default constructor. This
constructor is used for field default values. If a field shouldn't have a default
value, annotation IgnoreDefaultValue can be used. This can be handy e.g. for
id values that should not have default value in client side model.

If a class doesn't have a special converter class, it should have a toString() method. This
method is used when converting values that don't have a converter. ToString() method implementation
should return the value as it should be in the target model file. I.e. if it's represented in string form, the
return value should be quoted appropriately.

**Note:** Nested classes have to be static classes in order to work. This limitation is due to class
instantion via reflection.

#### Default Conversion Process

The default base value converter implementation first tries to match the convertable object by
class' exact equality (i.e. class hash code). If it can't find the match, then it tries to find match for
the super class and if no match is found, then for the interfaces. The search is recursive so the whole hierarchy
is used in the search. The search is conducted in top-to-bottom manner where the first match wins.

If no class is found in the search, the object is converted using the to string converter.
Currently there is no way to figure out how the classes that should be converted with default
toString method and the classes that shouldn't be converted at all other than manually specifying
the classes with _BaseValueConverterManager.addConverter(ValueConverter, Class[])_ method. The library's default
implementations will rely on the to string converter for all non-matching classes in order to widely support the
Java's toString() methods on various classes (e.g. BigDecimal and BigInteger).


Configuring
-----------

### Model Naming Strategies

In order to customize the produced model's name, a model naming strategy can be implemented. It basically
takes a Model object and returns the name for the model.

